import java.util.*;

public class SortingSearchingAlgorithms {
    
    // Блочная (корзинная) сортировка
    public static List<Integer> bucketSort(List<Integer> arr) {
        if (arr.isEmpty()) return arr;
        
        int minVal = Collections.min(arr);
        int maxVal = Collections.max(arr);
        int bucketCount = arr.size();
        
        List<List<Integer>> buckets = new ArrayList<>();
        for (int i = 0; i < bucketCount; i++) {
            buckets.add(new ArrayList<>());
        }
        
        for (int num : arr) {
            int index = (int) ((num - minVal) / (double) (maxVal - minVal) * (bucketCount - 1));
            buckets.get(index).add(num);
        }
        
        List<Integer> result = new ArrayList<>();
        for (List<Integer> bucket : buckets) {
            Collections.sort(bucket);
            result.addAll(bucket);
        }
        
        return result;
    }
    
    // Блинная сортировка
    public static void pancakeSort(int[] arr) {
        for (int currSize = arr.length; currSize > 1; currSize--) {
            int maxIdx = findMaxIndex(arr, currSize);
            
            if (maxIdx != currSize - 1) {
                if (maxIdx != 0) {
                    flip(arr, maxIdx + 1);
                }
                flip(arr, currSize);
            }
        }
    }
    
    private static int findMaxIndex(int[] arr, int n) {
        int maxIdx = 0;
        for (int i = 0; i < n; i++) {
            if (arr[i] > arr[maxIdx]) {
                maxIdx = i;
            }
        }
        return maxIdx;
    }
    
    private static void flip(int[] arr, int k) {
        int i = 0;
        while (i < k / 2) {
            int temp = arr[i];
            arr[i] = arr[k - i - 1];
            arr[k - i - 1] = temp;
            i++;
        }
    }
    
    // Сортировка бусинами (гравитационная)
    public static List<Integer> beadSort(List<Integer> arr) {
        if (arr.isEmpty()) return arr;
        
        int maxVal = Collections.max(arr);
        int n = arr.size();
        
        int[][] beads = new int[maxVal][n];
        
        // Расставляем бусины
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < arr.get(i); j++) {
                beads[j][i] = 1;
            }
        }
        
        // "Падаем" бусинами
        for (int i = 0; i < maxVal; i++) {
            int sum = 0;
            for (int j = 0; j < n; j++) {
                sum += beads[i][j];
            }
            
            for (int j = 0; j < n - sum; j++) {
                beads[i][j] = 0;
            }
            for (int j = n - sum; j < n; j++) {
                beads[i][j] = 1;
            }
        }
        
        // Собираем результат
        List<Integer> result = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            int sum = 0;
            for (int j = 0; j < maxVal; j++) {
                sum += beads[j][i];
            }
            result.add(sum);
        }
        
        return result;
    }
    
    // Поиск скачками
    public static int jumpSearch(int[] arr, int target) {
        int n = arr.length;
        int step = (int) Math.sqrt(n);
        int prev = 0;
        
        while (arr[Math.min(step, n) - 1] < target) {
            prev = step;
            step += (int) Math.sqrt(n);
            if (prev >= n) return -1;
        }
        
        for (int i = prev; i < Math.min(step, n); i++) {
            if (arr[i] == target) return i;
        }
        
        return -1;
    }
    
    // Экспоненциальный поиск
    public static int exponentialSearch(int[] arr, int target) {
        if (arr[0] == target) return 0;
        
        int n = arr.length;
        int i = 1;
        while (i < n && arr[i] <= target) {
            i *= 2;
        }
        
        return binarySearch(arr, target, i / 2, Math.min(i, n - 1));
    }
    
    private static int binarySearch(int[] arr, int target, int left, int right) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) return mid;
            else if (arr[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return -1;
    }
    
    // Тернарный поиск
    public static int ternarySearch(int[] arr, int target) {
        return ternarySearchRecursive(arr, target, 0, arr.length - 1);
    }
    
    private static int ternarySearchRecursive(int[] arr, int target, int left, int right) {
        if (left > right) return -1;
        
        int mid1 = left + (right - left) / 3;
        int mid2 = right - (right - left) / 3;
        
        if (arr[mid1] == target) return mid1;
        if (arr[mid2] == target) return mid2;
        
        if (target < arr[mid1]) {
            return ternarySearchRecursive(arr, target, left, mid1 - 1);
        } else if (target > arr[mid2]) {
            return ternarySearchRecursive(arr, target, mid2 + 1, right);
        } else {
            return ternarySearchRecursive(arr, target, mid1 + 1, mid2 - 1);
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        
        System.out.println("Исходный массив: " + Arrays.toString(arr));
        
        // Блочная сортировка
        List<Integer> list = new ArrayList<>();
        for (int num : arr) list.add(num);
        System.out.println("Блочная сортировка: " + bucketSort(list));
        
        // Блинная сортировка
        int[] pancakeArr = arr.clone();
        pancakeSort(pancakeArr);
        System.out.println("Блинная сортировка: " + Arrays.toString(pancakeArr));
        
        // Сортировка бусинами
        List<Integer> beadList = Arrays.asList(3, 1, 4, 1, 5);
        System.out.println("Сортировка бусинами: " + beadSort(beadList));
        
        // Поисковые алгоритмы
        int[] sortedArr = Arrays.copyOf(arr, arr.length);
        Arrays.sort(sortedArr);
        int target = 25;
        
        System.out.println("\nПоиск " + target + " в отсортированном массиве:");
        System.out.println("Поиск скачками: " + jumpSearch(sortedArr, target));
        System.out.println("Экспоненциальный поиск: " + exponentialSearch(sortedArr, target));
        System.out.println("Тернарный поиск: " + ternarySearch(sortedArr, target));
    }
}
