#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <limits>

using namespace std;

// Блочная (корзинная) сортировка
vector<int> bucketSort(vector<int>& arr) {
    if (arr.empty()) return arr;
    
    int minVal = *min_element(arr.begin(), arr.end());
    int maxVal = *max_element(arr.begin(), arr.end());
    int bucketCount = arr.size();
    
    vector<vector<int>> buckets(bucketCount);
    
    for (int num : arr) {
        int index = static_cast<int>((num - minVal) / static_cast<double>(maxVal - minVal) * (bucketCount - 1));
        buckets[index].push_back(num);
    }
    
    vector<int> result;
    for (auto& bucket : buckets) {
        sort(bucket.begin(), bucket.end());
        result.insert(result.end(), bucket.begin(), bucket.end());
    }
    
    return result;
}

// Блинная сортировка
void pancakeSort(vector<int>& arr) {
    auto flip = [](vector<int>& arr, int k) {
        int i = 0;
        while (i < k / 2) {
            swap(arr[i], arr[k - i - 1]);
            i++;
        }
    };
    
    auto findMaxIndex = [](vector<int>& arr, int n) {
        int maxIdx = 0;
        for (int i = 0; i < n; i++) {
            if (arr[i] > arr[maxIdx]) {
                maxIdx = i;
            }
        }
        return maxIdx;
    };
    
    int n = arr.size();
    for (int currSize = n; currSize > 1; currSize--) {
        int maxIdx = findMaxIndex(arr, currSize);
        
        if (maxIdx != currSize - 1) {
            if (maxIdx != 0) {
                flip(arr, maxIdx + 1);
            }
            flip(arr, currSize);
        }
    }
}

// Сортировка бусинами (гравитационная)
vector<int> beadSort(vector<int>& arr) {
    if (arr.empty()) return arr;
    
    int maxVal = *max_element(arr.begin(), arr.end());
    int n = arr.size();
    
    vector<vector<int>> beads(maxVal, vector<int>(n, 0));
    
    // Расставляем бусины
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < arr[i]; j++) {
            beads[j][i] = 1;
        }
    }
    
    // "Падаем" бусинами
    for (int i = 0; i < maxVal; i++) {
        int sum = 0;
        for (int j = 0; j < n; j++) {
            sum += beads[i][j];
        }
        
        for (int j = 0; j < n - sum; j++) {
            beads[i][j] = 0;
        }
        for (int j = n - sum; j < n; j++) {
            beads[i][j] = 1;
        }
    }
    
    // Собираем результат
    vector<int> result(n, 0);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < maxVal; j++) {
            result[i] += beads[j][i];
        }
    }
    
    return result;
}

// Поиск скачками
int jumpSearch(vector<int>& arr, int target) {
    int n = arr.size();
    int step = sqrt(n);
    int prev = 0;
    
    while (arr[min(step, n) - 1] < target) {
        prev = step;
        step += sqrt(n);
        if (prev >= n) return -1;
    }
    
    for (int i = prev; i < min(step, n); i++) {
        if (arr[i] == target) return i;
    }
    
    return -1;
}

// Экспоненциальный поиск
int exponentialSearch(vector<int>& arr, int target) {
    if (arr[0] == target) return 0;
    
    int n = arr.size();
    int i = 1;
    while (i < n && arr[i] <= target) {
        i *= 2;
    }
    
    // Бинарный поиск в найденном диапазоне
    int left = i / 2;
    int right = min(i, n - 1);
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    
    return -1;
}

// Тернарный поиск
int ternarySearch(vector<int>& arr, int target, int left, int right) {
    if (left > right) return -1;
    
    int mid1 = left + (right - left) / 3;
    int mid2 = right - (right - left) / 3;
    
    if (arr[mid1] == target) return mid1;
    if (arr[mid2] == target) return mid2;
    
    if (target < arr[mid1]) {
        return ternarySearch(arr, target, left, mid1 - 1);
    } else if (target > arr[mid2]) {
        return ternarySearch(arr, target, mid2 + 1, right);
    } else {
        return ternarySearch(arr, target, mid1 + 1, mid2 - 1);
    }
}

int ternarySearch(vector<int>& arr, int target) {
    return ternarySearch(arr, target, 0, arr.size() - 1);
}

int main() {
    vector<int> arr = {64, 34, 25, 12, 22, 11, 90};
    
    cout << "Исходный массив: ";
    for (int num : arr) cout << num << " ";
    cout << endl;
    
    // Блочная сортировка
    vector<int> bucketResult = bucketSort(arr);
    cout << "Блочная сортировка: ";
    for (int num : bucketResult) cout << num << " ";
    cout << endl;
    
    // Блинная сортировка
    vector<int> pancakeArr = arr;
    pancakeSort(pancakeArr);
    cout << "Блинная сортировка: ";
    for (int num : pancakeArr) cout << num << " ";
    cout << endl;
    
    // Сортировка бусинами
    vector<int> beadArr = {3, 1, 4, 1, 5};
    vector<int> beadResult = beadSort(beadArr);
    cout << "Сортировка бусинами: ";
    for (int num : beadResult) cout << num << " ";
    cout << endl;
    
    // Поисковые алгоритмы
    vector<int> sortedArr = arr;
    sort(sortedArr.begin(), sortedArr.end());
    int target = 25;
    
    cout << "\nПоиск " << target << " в отсортированном массиве:" << endl;
    cout << "Поиск скачками: " << jumpSearch(sortedArr, target) << endl;
    cout << "Экспоненциальный поиск: " << exponentialSearch(sortedArr, target) << endl;
    cout << "Тернарный поиск: " << ternarySearch(sortedArr, target) << endl;
    
    return 0;
}

//for ternary search
#include <iostream>
using namespace std;

int ternarySearch(int arr[], int l, int r, int key)
{
    while (r >= l) {
        int mid1 = l + (r - l) / 3;
        int mid2 = r - (r - l) / 3;

        // Check if the key is present at mid1
        if (arr[mid1] == key) {
            return mid1;
        }

        // Check if the key is present at mid2
        if (arr[mid2] == key) {
            return mid2;
        }

        // Determine which segment to search next
        if (key < arr[mid1]) {
            r = mid1 - 1;
        }
        else if (key > arr[mid2]) {
            l = mid2 + 1;
        }
        else {
            l = mid1 + 1;
            r = mid2 - 1;
        }
    }

    // If the element is not found
    return -1;
}

int main()
{
    int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    int n = sizeof(arr) / sizeof(arr[0]);
    int key = 5;

    int index = ternarySearch(arr, 0, n - 1, key);

    if (index != -1) {
        cout << "Element found at index " << index << endl;
    }
    else {
        cout << "Element not found in the array" << endl;
    }

    return 0;
}
